# :vim setet ts=4 sw=4:
#==================================================================================
#        Copyright (c) 2020 Nokia
#        Copyright (c) 2020 AT&T Intellectual Property.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#==================================================================================

#	Mnemonic:	scrape_types.sh
#	Abstract:	This parses the RIC_msg_types header file and geneates
#				some doc.  See the header file for a description of what
#				is recognised by this parser.
#	Date:		23 June 2020
#	Author:		E. Scott Daniels
# ----------------------------------------------------------------------------------


sdir="../../../docs"			# dir where RTD scraper looks
input=../../../src/rmr/common/include/RIC_message_types.h
xsrc=/tmp/PID$$.xfm
export XFM_OUTPUT_TYPE=rst		# it should be this
out_suffix=rst

while [[ $1 == -* ]]
do
	case $1 in
		-o)	export XFM_OUTPUT_TYPE=$2
			out_suffix=$2
			shift
			;;

		-t) sdir=$2; shift;;
	esac

	shift
done

export OUTPUT_TYPE=$XFM_OUTPUT_TYPE			# compat with project setup

cat <<endKat >$xsrc
.**  CAUTION:
.**  This {X}fm source is generated by $0 in $PWD. Any edits
.**  are very likely to be lost.
.**

.dv doc_title RIC Message Types
.im setup.im

endKat

sed 's/^ *//' $input | awk '
	BEGIN {
		space_ok = 1

		off = 0				# snarf types
		anything = 1
		desc = 2
	}

	# starting with token stk, build remaining tokens into a record
	function build_rec( stk ) {
		rec = ""
		for( ; stk <= NF; stk++ ) {
			rec = rec $(stk) " "
		}
		return rec
	}

	# ------------------------------------------------------------------------

	snarf && /^$/ && space_ok {
		printf( "&space\n\n" );
		space_ok = 0						# eat multiple blank lines
		if( snarf == desc ) {
			snarf = off
		}
		next
	}

	$1 == "/*+" {
		expect_header = 1
		snarf = anything
		space_ok = 1
		next
	}

	expect_header {
		if( dl_open ) {
			printf( "&end_dlist\n" );
			dl_open = 0
		}
		printf( "\n&h2(%s)\n", $0 )
		space_ok = 1
		expect_header = 0
		next
	}

	snarf && $1 == "*/" {
		snarf = off
		space_ok = 0
		next
	}

	/^#[ ]*define/ {
		if( $4 == "//--" ) {				# ignored completely
			next
		}

		if( ! dl_open ) {
			printf( "\n&beg_dlist( 1.5i Helvetica-bold : : 30,70) \n" )
			dl_open = 1
		}

		if( $4 == "//+" ) {
			printf( "&di(%s) %s\n", $2, build_rec( 5 ) )
		} else {
			if( $4 == "//-" ) {
				printf( "&di(%s) deprecated\n", $2 )
			} else {
				printf( "&di(%s) &break\n", $2 )
			}
		}

		snarf = desc;						# snarf next only if //+ is the first token
		next
	}

	snarf == desc {
		if( $1 == "//+" ) {					# continued description, add it on
			printf( "%s\n", build_rec( 5 ) )
		} else {
			snarf = off
		}
		next
	}

	snarf == anything {
		print
		next
	}

	END {
		if( dl_open ) {
			printf( "&end_dlist\n" );
		}

		printf( ".qu\n" )
	}
' >>$xsrc

tfm $xsrc stdout | sed 's/^ //; s/ *$//' >$sdir/msg_types.$out_suffix


rm -f /tmp/PID$$.*


